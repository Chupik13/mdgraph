# Архитектурный план миграции mdgraph на MVVM

**Версия документа:** 1.0
**Дата:** 2025-11-28
**Статус:** Утвержден

---

## Содержание

1. [Введение](#1-введение)
2. [Анализ текущей архитектуры](#2-анализ-текущей-архитектуры)
3. [Целевая архитектура MVVM](#3-целевая-архитектура-mvvm)
4. [Описание слоев архитектуры](#4-описание-слоев-архитектуры)
5. [Ключевые интерфейсы и контракты](#5-ключевые-интерфейсы-и-контракты)
6. [Система Dependency Injection](#6-система-dependency-injection)
7. [Потоки данных и взаимодействия](#7-потоки-данных-и-взаимодействия)
8. [Оптимизации производительности](#8-оптимизации-производительности)
9. [Пофазный план реализации](#9-пофазный-план-реализации)
10. [Структура файлов проекта](#10-структура-файлов-проекта)
11. [Риски и митигация](#11-риски-и-митигация)
12. [Критерии приемки](#12-критерии-приемки)

---

## 1. Введение

### 1.1 Цель документа

Данный документ описывает архитектуру миграции приложения mdgraph с текущей структуры на паттерн MVVM (Model-View-ViewModel) с соблюдением принципов SOLID. Документ предназначен для разработчиков и содержит достаточно информации для последовательной реализации всех компонентов системы.

### 1.2 О проекте mdgraph

**mdgraph** — десктопное приложение для визуализации markdown-файлов как интерактивного графа знаний. Приложение сканирует директорию с markdown-файлами, извлекает wiki-ссылки формата `[[имя]]` и строит визуальный граф связей между заметками.

### 1.3 Технологический стек

| Компонент | Технология | Версия |
|-----------|------------|--------|
| Backend | Tauri + Rust | 2.x |
| Frontend | React + TypeScript | 19.x |
| Сборка | Vite | 6.x |
| Визуализация графа | vis-network | 9.x |
| Управление состоянием | Zustand + Immer | 5.x |
| Стилизация | Tailwind CSS | 4.x |

### 1.4 Метрики текущей кодовой базы

- **Frontend:** ~2500 строк TypeScript/React
- **Backend:** ~2300 строк Rust
- **Компоненты React:** 5 основных
- **Zustand stores:** 6 штук
- **Tauri commands:** 5 команд
- **Custom hooks:** 15+ штук

---

## 2. Анализ текущей архитектуры

### 2.1 Диаграмма текущей архитектуры

```
┌─────────────────────────────────────────────────────────────────────┐
│                      ТЕКУЩАЯ АРХИТЕКТУРА                            │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  ┌─────────────┐   ┌─────────────┐   ┌─────────────┐               │
│  │ GraphCanvas │   │ CommandLine │   │PreviewPopup │  ← Views      │
│  └──────┬──────┘   └──────┬──────┘   └──────┬──────┘               │
│         │                 │                 │                       │
│         ▼                 ▼                 ▼                       │
│  ┌────────────────────────────────────────────────────────┐        │
│  │              Хуки (смешанная логика)                   │        │
│  │  useKeybindings, useVimNavigation, useNodeColoring...  │        │
│  └────────────────────────────────────────────────────────┘        │
│         │                 │                 │                       │
│         ▼                 ▼                 ▼                       │
│  ┌────────────────────────────────────────────────────────┐        │
│  │           GraphDataService (God Object)                │        │
│  │     40+ методов, управление данными + vis-network      │        │
│  └────────────────────────────────────────────────────────┘        │
│         │                 │                 │                       │
│         ▼                 ▼                 ▼                       │
│  ┌─────────────┐   ┌─────────────┐   ┌─────────────┐               │
│  │coloringStore│   │keybindStore │   │ appModeStore│  ← Stores     │
│  │(side-effects│   │             │   │             │               │
│  └─────────────┘   └─────────────┘   └─────────────┘               │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### 2.2 Выявленные проблемы Frontend

#### 2.2.1 GraphDataService — God Object

**Расположение:** `src/features/graph/services/GraphDataService.ts`
**Размер:** 490 строк, 40+ методов

**Описание проблемы:**
Сервис выполняет слишком много обязанностей: управление DataSet vis-network, отслеживание phantom-нодов, управление статусом загрузки, хранение начальных данных, предоставление Network instance, система подписок на изменения.

**Нарушения SOLID:**
- **SRP (Single Responsibility):** Один класс отвечает за 6+ различных областей
- **ISP (Interface Segregation):** Клиенты вынуждены зависеть от методов, которые не используют

#### 2.2.2 useKeybindings — монолитный хук

**Расположение:** `src/features/keybindings/hooks/useKeybindings.ts`
**Размер:** 340 строк, 20+ case-веток в switch

**Описание проблемы:**
Хук обрабатывает все горячие клавиши приложения в одном месте. Содержит бизнес-логику навигации, выбора нодов, открытия файлов, управления режимами приложения. Имеет 15 зависимостей в useCallback.

**Нарушения SOLID:**
- **SRP:** Один хук отвечает за все действия приложения
- **OCP (Open/Closed):** Для добавления нового действия нужно модифицировать существующий код

#### 2.2.3 coloringStore — смешение состояния и побочных эффектов

**Расположение:** `src/features/coloring/store/coloringStore.ts`
**Размер:** 256 строк

**Описание проблемы:**
Store напрямую вызывает методы vis-network (`network.selectNodes()`, `network.unselectAll()`) внутри action-ов. Это нарушает принцип разделения слоев — store должен управлять только состоянием.

**Нарушения SOLID:**
- **SRP:** Store отвечает и за состояние, и за манипуляции с DOM
- **DIP (Dependency Inversion):** Высокоуровневый модуль зависит от низкоуровневой реализации vis-network

#### 2.2.4 useNodeColoring — неоптимальная перерисовка

**Расположение:** `src/features/coloring/hooks/useNodeColoring.ts`
**Размер:** 106 строк

**Описание проблемы:**
При любом изменении состояния (выбор ноды, фокус, подсветка) хук пересчитывает и обновляет стили для ВСЕХ нодов графа. Для графа с 1000+ нодами это создает значительную нагрузку.

#### 2.2.5 Множественное создание CameraService

**Расположение:** useKeybindings.ts, useVimNavigation.ts, useConnectedNavigation.ts, useNodeSearch.ts

**Описание проблемы:**
CameraService создается заново (`new CameraService()`) в 4+ разных местах вместо использования единственного экземпляра через Dependency Injection.

#### 2.2.6 Дублирование логики навигации

**Расположение:** `src/features/navigation/hooks/*.ts`

**Описание проблемы:**
Паттерн "focusNode + focusOnNode" повторяется в useVimNavigation, useConnectedNavigation и других хуках. Каждый раз заново получается CameraService и вызываются одинаковые методы.

#### 2.2.7 Отсутствие Dependency Injection

**Описание проблемы:**
Все зависимости импортируются напрямую через `import`. Это делает невозможным:
- Юнит-тестирование с моками
- Замену реализаций
- Контроль жизненного цикла сервисов

### 2.3 Выявленные проблемы Backend

#### 2.3.1 Race condition в watcher

**Расположение:** `src-tauri/src/watcher/delta.rs`, строка ~150

**Описание проблемы:**
При удалении ссылки из файла, метод `count_incoming_links()` вызывается ДО фактического удаления ссылки из кэша. Это приводит к неправильному подсчету и потенциально некорректному удалению phantom-нодов.

**Последствия:** Граф может содержать "осиротевшие" phantom-ноды или преждевременно удалять нужные.

#### 2.3.2 Двойной парсинг в build_graph

**Расположение:** `src-tauri/src/graph/mod.rs`

**Описание проблемы:**
Функция `build_graph` вызывает `parser::parse_markdown()` для каждого файла дважды: первый раз для подсчета ссылок и создания ребер, второй раз для извлечения хэштегов при создании нодов.

**Последствия:** Удвоенное время парсинга, особенно заметное на больших коллекциях файлов.

#### 2.3.3 Компиляция regex при каждом вызове

**Расположение:** `src-tauri/src/parser/mod.rs`

**Описание проблемы:**
Функции `extract_wiki_links()` и `extract_hashtags()` компилируют регулярные выражения при каждом вызове через `Regex::new()`. При парсинге 10,000 файлов это 20,000 компиляций regex.

**Последствия:** Значительное замедление при обработке больших коллекций.

#### 2.3.4 O(n) подсчет входящих ссылок

**Расположение:** `src-tauri/src/watcher/cache.rs`, метод `count_incoming_links()`

**Описание проблемы:**
Для подсчета входящих ссылок метод итерирует по ВСЕМ файлам и их ссылкам. Сложность O(n*m), где n — количество файлов, m — среднее количество ссылок.

**Последствия:** Замедление file watcher при частых изменениях файлов.

#### 2.3.5 Отсутствие валидации конфигурации

**Расположение:** `src-tauri/src/config/mod.rs`

**Описание проблемы:**
Конфигурация загружается без проверки валидности путей. Если `root_dir` не существует или недоступен, ошибка возникнет только при попытке сканирования.

#### 2.3.6 Дублирование кода в commands

**Расположение:** `src-tauri/src/commands/mod.rs`

**Описание проблемы:**
Логика построения пути к файлу (`PathBuf::from(&root_dir).push(format!("{}.md", node_id))`) повторяется в `open_file`, `create_phantom_node` и `read_note`.

### 2.4 Проблемы интеграции Frontend-Backend

#### 2.4.1 Дублирование типов

Типы данных (Node, Edge, GraphData, AppConfig) определены отдельно в Rust и TypeScript. При изменении структуры в одном месте нужно вручную обновлять в другом.

#### 2.4.2 Примитивная обработка ошибок

Все ошибки Rust передаются во frontend как простые строки (`Result<T, String>`). Нет типизированных кодов ошибок, нет возможности дифференцированной обработки.

#### 2.4.3 Race conditions в дельта-событиях

События `graph-delta` приходят по одному. При быстрой последовательности изменений возможна рассинхронизация состояния.

---

## 3. Целевая архитектура MVVM

### 3.1 Обзор паттерна MVVM

**MVVM (Model-View-ViewModel)** — архитектурный паттерн, разделяющий приложение на три слоя:

- **Model (Модель):** Данные и бизнес-логика работы с данными
- **View (Представление):** Визуальные компоненты, отображение данных
- **ViewModel (Модель представления):** Посредник между Model и View, содержит логику представления

### 3.2 Диаграмма целевой архитектуры

```
┌─────────────────────────────────────────────────────────────────────┐
│                      ЦЕЛЕВАЯ АРХИТЕКТУРА MVVM                       │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │                      VIEW LAYER                              │   │
│  │         (React компоненты — только отображение)              │   │
│  │                                                              │   │
│  │  ┌───────────┐ ┌───────────┐ ┌───────────┐ ┌───────────┐    │   │
│  │  │GraphCanvas│ │CommandLine│ │PreviewPop │ │GraphCtrls │    │   │
│  │  └─────┬─────┘ └─────┬─────┘ └─────┬─────┘ └─────┬─────┘    │   │
│  │        │             │             │             │           │   │
│  └────────┼─────────────┼─────────────┼─────────────┼───────────┘   │
│           │             │             │             │               │
│           ▼             ▼             ▼             ▼               │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │                   VIEWMODEL LAYER                            │   │
│  │         (Zustand stores — бизнес-логика UI)                  │   │
│  │                                                              │   │
│  │  ┌─────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐         │   │
│  │  │ Graph   │ │Navigation│ │ Coloring │ │Keybinding│         │   │
│  │  │ViewModel│ │ ViewModel│ │ ViewModel│ │ ViewModel│         │   │
│  │  └────┬────┘ └────┬─────┘ └────┬─────┘ └────┬─────┘         │   │
│  │       │           │            │            │                │   │
│  │  ┌────┴───┐  ┌────┴────┐  ┌────┴────┐  ┌────┴────┐          │   │
│  │  │ Search │  │ Camera  │  │ Preview │  │  Mode   │          │   │
│  │  │ViewModel │ViewModel│  │ViewModel│  │ViewModel│          │   │
│  │  └────────┘  └─────────┘  └─────────┘  └─────────┘          │   │
│  │                                                              │   │
│  └──────────────────────────┬───────────────────────────────────┘   │
│                             │                                       │
│                             ▼                                       │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │                     MODEL LAYER                              │   │
│  │         (Сервисы — чистая работа с данными)                  │   │
│  │                                                              │   │
│  │  ┌────────────┐ ┌────────────┐ ┌────────────┐               │   │
│  │  │   IGraph   │ │ INavigation│ │  ICamera   │               │   │
│  │  │ Repository │ │  Service   │ │  Service   │               │   │
│  │  └────────────┘ └────────────┘ └────────────┘               │   │
│  │                                                              │   │
│  │  ┌────────────┐ ┌────────────┐ ┌────────────┐               │   │
│  │  │ IColoring  │ │  IEvent    │ │  IConfig   │               │   │
│  │  │  Service   │ │    Bus     │ │ Repository │               │   │
│  │  └────────────┘ └────────────┘ └────────────┘               │   │
│  │                                                              │   │
│  └──────────────────────────┬───────────────────────────────────┘   │
│                             │                                       │
│                             ▼                                       │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │                 INFRASTRUCTURE LAYER                         │   │
│  │         (Внешние зависимости и адаптеры)                     │   │
│  │                                                              │   │
│  │  ┌────────────┐ ┌────────────┐ ┌────────────┐               │   │
│  │  │VisNetwork  │ │   Tauri    │ │  DataSet   │               │   │
│  │  │  Adapter   │ │  Adapter   │ │  Manager   │               │   │
│  │  └────────────┘ └────────────┘ └────────────┘               │   │
│  │                                                              │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### 3.3 Принципы новой архитектуры

#### 3.3.1 Однонаправленный поток данных

```
User Action → View → ViewModel → Model → ViewModel → View (update)
```

View никогда не обращается напрямую к Model. Все взаимодействие через ViewModel.

#### 3.3.2 Dependency Injection

Все сервисы создаются в контейнере и передаются через React Context. Это обеспечивает:
- Контролируемый жизненный цикл
- Возможность замены реализаций (для тестов)
- Явные зависимости

#### 3.3.3 Разделение ответственности

- **View:** Только отображение и передача пользовательских действий
- **ViewModel:** Логика UI, трансформация данных для отображения
- **Model:** Работа с данными, бизнес-правила

#### 3.3.4 Single Source of Truth

Данные графа хранятся в единственном месте — GraphRepository. Все остальные части системы получают данные оттуда.

---

## 4. Описание слоев архитектуры

### 4.1 View Layer (Слой представления)

#### 4.1.1 Назначение

Слой View отвечает исключительно за:
- Рендеринг UI на основе данных из ViewModel
- Передачу пользовательских событий в ViewModel
- Управление локальным UI-состоянием (анимации, hover-эффекты)

#### 4.1.2 Компоненты View Layer

| Компонент | Назначение | Используемые ViewModels |
|-----------|------------|------------------------|
| **GraphCanvas** | Контейнер для vis-network графа | GraphViewModel, ColoringViewModel |
| **CommandLine** | Строка поиска и команд | SearchViewModel, KeybindingViewModel |
| **PreviewPopup** | Popup с превью markdown-файла | PreviewViewModel |
| **GraphControls** | Кнопки управления камерой | CameraViewModel |

#### 4.1.3 Правила для View Layer

1. **Никакой бизнес-логики** — компоненты не принимают решений, только отображают
2. **Никаких прямых импортов сервисов** — только через хуки ViewModel
3. **Минимальное локальное состояние** — только для UI-специфичных вещей
4. **Декларативный стиль** — описание "что отобразить", а не "как"

### 4.2 ViewModel Layer (Слой моделей представления)

#### 4.2.1 Назначение

ViewModel — это "мост" между View и Model:
- Хранит состояние UI (выбранная нода, режим приложения, и т.д.)
- Трансформирует данные из Model в формат, удобный для View
- Обрабатывает пользовательские действия
- Оркестрирует вызовы сервисов Model

#### 4.2.2 ViewModels и их ответственности

| ViewModel | Ответственность | Используемые сервисы |
|-----------|-----------------|---------------------|
| **GraphViewModel** | Загрузка графа, синхронизация с backend | IGraphRepository, IEventBus, IConfigRepository |
| **NavigationViewModel** | Навигация по графу (hjkl, w/b) | INavigationService, ICameraService, IColoringService |
| **ColoringViewModel** | Визуальное состояние нодов (выбор, фокус, подсветка) | IColoringService, IGraphRepository |
| **KeybindingViewModel** | Обработка горячих клавиш | IKeybindingService, все остальные ViewModels |
| **SearchViewModel** | Поиск по нодам, фильтрация | IGraphRepository, IColoringService |
| **CameraViewModel** | Управление камерой (zoom, fit, focus) | ICameraService |
| **PreviewViewModel** | Загрузка и отображение превью | IConfigRepository, Tauri commands |
| **ModeViewModel** | Режимы приложения (normal, search, command) | IEventBus |

#### 4.2.3 Реализация ViewModels

ViewModels реализуются как **Zustand stores** с подписками на сервисы Model. Каждый ViewModel:

1. Получает сервисы через DI при создании
2. Подписывается на изменения релевантных данных
3. Экспортирует состояние и методы-действия
4. Выполняет очистку при размонтировании

### 4.3 Model Layer (Слой модели)

#### 4.3.1 Назначение

Model Layer содержит:
- Доменные сущности (Node, Edge, GraphData)
- Сервисы для работы с данными
- Бизнес-правила (что такое phantom-нода, как вычислить связи)

#### 4.3.2 Сервисы Model Layer

| Сервис | Ответственность |
|--------|-----------------|
| **IGraphRepository** | CRUD операции с нодами и ребрами, единый источник данных графа |
| **INavigationService** | Алгоритмы навигации (пространственная, по связям) |
| **ICameraService** | Управление viewport vis-network |
| **IColoringService** | Вычисление стилей нодов, управление визуальным состоянием |
| **IEventBus** | Pub/sub для межкомпонентной коммуникации |
| **IKeybindingService** | Маппинг клавиш на действия |
| **IConfigRepository** | Загрузка и доступ к конфигурации |

#### 4.3.3 Правила для Model Layer

1. **Не знает о View** — сервисы не должны содержать UI-специфичной логики
2. **Stateless где возможно** — предпочитать чистые функции
3. **Интерфейсы над реализациями** — все сервисы определяются через интерфейсы
4. **Единственный источник правды** — данные графа только в GraphRepository

### 4.4 Infrastructure Layer (Инфраструктурный слой)

#### 4.4.1 Назначение

Infrastructure Layer изолирует внешние зависимости:
- vis-network API
- Tauri IPC
- LocalStorage/IndexedDB
- Файловая система (через Tauri)

#### 4.4.2 Адаптеры Infrastructure Layer

| Адаптер | Внешняя зависимость | Предоставляет |
|---------|---------------------|---------------|
| **VisNetworkAdapter** | vis-network | Типизированный доступ к Network API |
| **TauriAdapter** | @tauri-apps/api | Типизированные команды и события |
| **DataSetManager** | vis-data DataSet | Управление DataSet нодов и ребер |

---

## 5. Ключевые интерфейсы и контракты

### 5.1 IGraphRepository

**Назначение:** Единый источник данных графа (ноды, ребра), управление DataSet.

**Методы чтения:**
| Метод | Описание | Возвращает |
|-------|----------|------------|
| `getNodes()` | Все ноды графа | Массив Node |
| `getEdges()` | Все ребра графа | Массив Edge |
| `getNode(nodeId)` | Нода по ID | Node или undefined |
| `getNodeIds()` | ID всех нод | Массив строк |
| `getConnectedNodeIds(nodeId)` | Входящие и исходящие связи | Объект с двумя Set |
| `isPhantom(nodeId)` | Является ли нода phantom | boolean |
| `isReady()` | Готов ли репозиторий к работе | boolean |

**Методы записи:**
| Метод | Описание | Параметры |
|-------|----------|-----------|
| `addNode(node)` | Добавить ноду | Объект Node |
| `removeNode(nodeId)` | Удалить ноду | ID ноды |
| `updateNode(node)` | Обновить ноду | Частичный объект Node с id |
| `updateNodes(nodes)` | Батч-обновление нод | Массив частичных Node |
| `addEdge(edge)` | Добавить ребро | Объект Edge |
| `removeEdge(edge)` | Удалить ребро | Объект Edge |

**Методы жизненного цикла:**
| Метод | Описание |
|-------|----------|
| `initialize(network)` | Инициализация с vis-network instance |
| `destroy()` | Очистка ресурсов |
| `subscribe(callback)` | Подписка на изменения, возвращает функцию отписки |

### 5.2 INavigationService

**Назначение:** Алгоритмы навигации по графу.

**Типы:**
- `Direction`: 'left' | 'right' | 'up' | 'down'
- `ConnectionDirection`: 'clockwise' | 'counterclockwise'

**Методы:**
| Метод | Описание | Параметры | Возвращает |
|-------|----------|-----------|------------|
| `navigateInDirection(direction)` | Пространственная навигация (hjkl) | Direction | ID ноды или null |
| `navigateConnected(direction)` | Навигация по связям (w/b) | ConnectionDirection | ID ноды или null |
| `navigateSearchResult(direction)` | Навигация по результатам поиска | 'next' или 'prev' | ID ноды или null |
| `navigateToNode(nodeId)` | Прямой переход к ноде | ID ноды | void |
| `getFocusedNodeId()` | Текущая нода в фокусе | — | ID или null |

**Алгоритм пространственной навигации:**
1. Получить позиции всех нод из vis-network
2. От текущей ноды найти ближайшую в указанном направлении
3. Учитывать угол (±45° от направления)
4. При отсутствии кандидатов — не перемещаться

**Алгоритм навигации по связям:**
1. Получить все связанные ноды (входящие + исходящие)
2. Отсортировать по углу относительно текущей ноды
3. Clockwise — следующая по часовой стрелке
4. Counterclockwise — предыдущая против часовой

### 5.3 ICameraService

**Назначение:** Управление viewport vis-network (позиция, масштаб, анимации).

**Методы:**
| Метод | Описание | Параметры |
|-------|----------|-----------|
| `focusOnNode(nodeId, scale?)` | Центрировать на ноде | ID ноды, опционально масштаб |
| `zoomIn(percent?)` | Увеличить масштаб | Процент увеличения (default 20%) |
| `zoomOut(percent?)` | Уменьшить масштаб | Процент уменьшения |
| `resetZoom()` | Сбросить масштаб к default | — |
| `fitAll(nodeIds?)` | Вписать ноды в viewport | Массив ID или все ноды |
| `getCurrentZoom()` | Текущий масштаб | — |
| `getCurrentPosition()` | Текущая позиция центра | — |
| `moveToPosition(x, y, scale?)` | Переместить камеру | Координаты и опционально масштаб |

**Параметры анимации:**
Все методы перемещения поддерживают опциональный объект анимации:
- `duration`: длительность в миллисекундах
- `easingFunction`: функция сглаживания ('linear', 'easeInOutQuad', и т.д.)

### 5.4 IColoringService

**Назначение:** Управление визуальным состоянием нод (выбор, фокус, подсветка связей).

**Состояние:**
| Свойство | Тип | Описание |
|----------|-----|----------|
| `selectedNodeId` | string или null | ID выбранной ноды |
| `focusedNodeId` | string или null | ID ноды в фокусе |
| `incomingNodeIds` | Set<string> | ID нод с входящими ссылками на selected |
| `outgoingNodeIds` | Set<string> | ID нод, на которые ссылается selected |
| `activeNodeIds` | Set<string> или null | ID активных нод (при поиске) |

**Методы управления состоянием:**
| Метод | Описание |
|-------|----------|
| `selectNode(nodeId)` | Выбрать ноду (или null для снятия выбора) |
| `focusNode(nodeId)` | Установить фокус на ноду |
| `setActiveNodes(nodeIds)` | Установить активные ноды (null — все активны) |
| `clearSelection()` | Очистить выбор, фокус и подсветку |

**Методы получения состояния:**
| Метод | Возвращает |
|-------|------------|
| `getSelectedNodeId()` | ID выбранной ноды или null |
| `getFocusedNodeId()` | ID ноды в фокусе или null |
| `getIncomingNodeIds()` | Set ID входящих нод |
| `getOutgoingNodeIds()` | Set ID исходящих нод |
| `getActiveNodeIds()` | Set активных нод или null |

**Методы вычисления стилей:**
| Метод | Описание |
|-------|----------|
| `computeNodeStyle(nodeId)` | Вычислить стиль для одной ноды |
| `computeChangedStyles(oldState, newState)` | Вычислить только изменившиеся стили |

**Типы нод для стилизации:**
- `selected` — выбранная нода (Space)
- `focused` — нода в фокусе (навигация)
- `incoming` — ноды, ссылающиеся на selected
- `outgoing` — ноды, на которые ссылается selected
- `phantom` — ноды-призраки (несуществующие файлы)
- `regular` — обычные ноды
- `inactive` — неактивные при поиске

### 5.5 IEventBus

**Назначение:** Pub/sub система для слабосвязанной коммуникации между компонентами.

**Типы событий:**
| Событие | Payload | Когда срабатывает |
|---------|---------|-------------------|
| `node:selected` | { nodeId: string или null } | При выборе/снятии выбора ноды |
| `node:focused` | { nodeId: string или null } | При изменении фокуса |
| `graph:loaded` | { nodeCount: number, edgeCount: number } | После загрузки графа |
| `graph:delta` | GraphDeltaEvent | При инкрементальном обновлении |
| `search:started` | { query: string } | При начале поиска |
| `search:completed` | { results: string[] } | При завершении поиска |
| `navigation:occurred` | { from: string, to: string, type: string } | При навигации |
| `camera:moved` | { x: number, y: number, scale: number } | При движении камеры |

**Методы:**
| Метод | Описание |
|-------|----------|
| `emit(event, payload)` | Отправить событие |
| `on(event, handler)` | Подписаться, возвращает функцию отписки |
| `once(event, handler)` | Подписаться на одно срабатывание |
| `off(event, handler)` | Отписаться |

### 5.6 IKeybindingService

**Назначение:** Маппинг клавиш на действия, поддержка кастомизации.

**Методы:**
| Метод | Описание |
|-------|----------|
| `findAction(event)` | Найти действие для KeyboardEvent |
| `getBindings()` | Получить все привязки |
| `registerAction(descriptor, action)` | Зарегистрировать привязку |
| `unregisterAction(descriptor)` | Удалить привязку |
| `loadBindings(bindings)` | Загрузить набор привязок |
| `resetToDefaults()` | Сбросить к значениям по умолчанию |

**Descriptor клавиши:**
- `key`: строка клавиши ('h', 'Space', 'Escape', и т.д.)
- `modifiers`: объект с ctrl, shift, alt, meta (опционально)

**Действия (KeybindingAction):**
| Действие | Описание |
|----------|----------|
| `graph.selectLeft/Right/Up/Down` | Навигация hjkl |
| `graph.focusNextConnected` | Навигация w |
| `graph.focusPrevConnected` | Навигация b |
| `graph.selectFocusedNode` | Выбор Space |
| `graph.openNode` | Открыть в редакторе o |
| `graph.previewNode` | Показать превью p |
| `search.nextResult/prevResult` | n/N в режиме поиска |
| `app.openSearchMode` | Режим поиска / |
| `app.openCommandMode` | Режим команд : |
| `app.escape` | Выход Escape |

### 5.7 IConfigRepository

**Назначение:** Загрузка и доступ к конфигурации приложения.

**Методы:**
| Метод | Описание | Возвращает |
|-------|----------|------------|
| `getConfig()` | Получить текущую конфигурацию | Promise<AppConfig> |
| `getRootDir()` | Получить корневую директорию | string или null |
| `getTemplatePath()` | Путь к шаблону phantom node | string или null |

---

## 6. Система Dependency Injection

### 6.1 Обзор DI-системы

DI-система обеспечивает:
1. Централизованное создание сервисов
2. Управление зависимостями между сервисами
3. Возможность подмены реализаций для тестов
4. Типобезопасный доступ к сервисам

### 6.2 ServiceContainer

**Структура контейнера:**

ServiceContainer — это объект, содержащий все сервисы приложения:
- `graphRepository`: IGraphRepository
- `navigationService`: INavigationService
- `cameraService`: ICameraService
- `coloringService`: IColoringService
- `eventBus`: IEventBus
- `keybindingService`: IKeybindingService
- `configRepository`: IConfigRepository

### 6.3 ServiceProvider

ServiceProvider — React-компонент, предоставляющий контейнер через Context:

**Использование в App.tsx:**
1. Создать контейнер через factory-функцию
2. Обернуть приложение в ServiceProvider
3. Компоненты получают сервисы через хуки

### 6.4 Хуки доступа к сервисам

Для каждого сервиса создается удобный хук:
- `useGraphRepository()` — доступ к IGraphRepository
- `useNavigationService()` — доступ к INavigationService
- `useCameraService()` — доступ к ICameraService
- `useColoringService()` — доступ к IColoringService
- `useEventBus()` — доступ к IEventBus

### 6.5 Factory-функции

**createProductionContainer(networkProvider):**
Создает контейнер с реальными реализациями сервисов.

Порядок создания (учитывает зависимости):
1. EventBus (без зависимостей)
2. GraphRepository (без зависимостей)
3. CameraService (зависит от networkProvider)
4. ColoringService (зависит от GraphRepository)
5. NavigationService (зависит от GraphRepository, ColoringService, CameraService, EventBus)
6. KeybindingService (без зависимостей)
7. ConfigRepository (без зависимостей)

**createTestContainer(overrides):**
Создает контейнер с mock-реализациями, позволяя переопределить отдельные сервисы.

### 6.6 Диаграмма зависимостей сервисов

```
                    ┌─────────────────┐
                    │   EventBus      │
                    └────────┬────────┘
                             │
    ┌────────────────────────┼────────────────────────┐
    │                        │                        │
    ▼                        ▼                        ▼
┌─────────┐          ┌──────────────┐          ┌───────────┐
│ Graph   │          │  Navigation  │          │  Config   │
│Repository│◄────────│   Service    │          │Repository │
└────┬────┘          └──────┬───────┘          └───────────┘
     │                      │
     │               ┌──────┴───────┐
     │               │              │
     ▼               ▼              ▼
┌─────────┐    ┌──────────┐   ┌──────────┐
│Coloring │    │  Camera  │   │Keybinding│
│ Service │    │  Service │   │ Service  │
└─────────┘    └──────────┘   └──────────┘
```

---

## 7. Потоки данных и взаимодействия

### 7.1 Поток: Инициализация приложения

```
┌─────────────────────────────────────────────────────────────────────┐
│                    ИНИЦИАЛИЗАЦИЯ ПРИЛОЖЕНИЯ                         │
└─────────────────────────────────────────────────────────────────────┘

1. App.tsx монтируется
   │
2. ├─► Создается ServiceContainer через createProductionContainer()
   │    │
   │    ├─► Создаются все сервисы в правильном порядке
   │    └─► Сервисы связываются через зависимости
   │
3. ├─► ServiceProvider оборачивает приложение
   │
4. ├─► GraphViewModel инициализируется
   │    │
   │    ├─► Вызывает ConfigRepository.getConfig()
   │    │    └─► Tauri command: get_config
   │    │
   │    └─► Вызывает Tauri command: scan_folder(root_dir)
   │         │
   │         └─► Backend сканирует директорию
   │              ├─► scanner: рекурсивно находит .md файлы
   │              ├─► parser: извлекает wiki-links и hashtags
   │              └─► graph: строит GraphData (nodes + edges)
   │
5. ├─► GraphRepository получает GraphData
   │    │
   │    └─► Инициализирует DataSet для vis-network
   │
6. ├─► GraphCanvas рендерит vis-network
   │    │
   │    └─► vis-network стабилизирует физику
   │
7. └─► Приложение готово к работе
```

### 7.2 Поток: Навигация по графу (клавиши hjkl)

```
┌─────────────────────────────────────────────────────────────────────┐
│                    НАВИГАЦИЯ (hjkl)                                 │
└─────────────────────────────────────────────────────────────────────┘

1. Пользователь нажимает 'l' (вправо)
   │
2. ├─► KeybindingViewModel перехватывает keydown
   │    │
   │    └─► KeybindingService.findAction(event) → 'graph.selectRight'
   │
3. ├─► KeybindingViewModel вызывает NavigationViewModel.navigateRight()
   │
4. ├─► NavigationViewModel вызывает NavigationService.navigateInDirection('right')
   │    │
   │    ├─► Получает позиции всех нод из vis-network
   │    ├─► Находит ближайшую ноду справа от текущей
   │    └─► Возвращает ID найденной ноды
   │
5. ├─► NavigationViewModel вызывает ColoringService.focusNode(newNodeId)
   │    │
   │    └─► ColoringService обновляет focusedNodeId
   │
6. ├─► ColoringViewModel вычисляет изменившиеся стили
   │    │
   │    ├─► Старая focused нода → regular стиль
   │    └─► Новая focused нода → focused стиль
   │
7. ├─► GraphRepository.updateNodes() применяет стили
   │
8. ├─► CameraService.focusOnNode(newNodeId) центрирует камеру
   │
9. └─► UI обновляется (перерисовка только затронутых нод)
```

### 7.3 Поток: Выбор ноды (Space)

```
┌─────────────────────────────────────────────────────────────────────┐
│                    ВЫБОР НОДЫ (Space)                               │
└─────────────────────────────────────────────────────────────────────┘

1. Пользователь нажимает Space на focused ноде
   │
2. ├─► KeybindingViewModel → 'graph.selectFocusedNode'
   │
3. ├─► ColoringViewModel.selectFocusedNode()
   │    │
   │    └─► ColoringService.selectNode(focusedNodeId)
   │         │
   │         ├─► Обновляет selectedNodeId
   │         │
   │         └─► GraphRepository.getConnectedNodeIds(nodeId)
   │              │
   │              ├─► Возвращает incoming: Set<nodeId>
   │              └─► Возвращает outgoing: Set<nodeId>
   │
4. ├─► ColoringService обновляет:
   │    ├─► selectedNodeId = nodeId
   │    ├─► incomingNodeIds = incoming
   │    └─► outgoingNodeIds = outgoing
   │
5. ├─► ColoringViewModel вычисляет изменившиеся стили:
   │    ├─► selected нода → selected стиль
   │    ├─► incoming ноды → incoming стиль
   │    └─► outgoing ноды → outgoing стиль
   │
6. ├─► GraphRepository.updateNodes() применяет стили
   │
7. ├─► CameraService.fitAll([selected, ...incoming, ...outgoing])
   │
8. └─► EventBus.emit('node:selected', { nodeId })
```

### 7.4 Поток: Синхронизация изменений файлов

```
┌─────────────────────────────────────────────────────────────────────┐
│                    FILE WATCHER SYNC                                │
└─────────────────────────────────────────────────────────────────────┘

1. Пользователь изменяет .md файл во внешнем редакторе
   │
2. ├─► Rust watcher детектирует изменение
   │    │
   │    └─► Debounce 300ms (группировка быстрых изменений)
   │
3. ├─► Watcher вычисляет delta:
   │    ├─► Парсит обновленный файл
   │    ├─► Сравнивает старые и новые ссылки
   │    └─► Формирует GraphDelta (added/removed nodes/edges)
   │
4. ├─► Tauri emit('graph-delta', delta)
   │
5. ├─► GraphViewModel получает событие
   │    │
   │    └─► Для каждого элемента delta:
   │         ├─► node-added → GraphRepository.addNode()
   │         ├─► node-removed → GraphRepository.removeNode()
   │         ├─► edge-added → GraphRepository.addEdge()
   │         └─► edge-removed → GraphRepository.removeEdge()
   │
6. ├─► ColoringViewModel обновляет стили затронутых нод
   │
7. ├─► Временно включается физика (500ms) для перестроения layout
   │
8. └─► UI обновляется
```

### 7.5 Поток: Поиск по нодам

```
┌─────────────────────────────────────────────────────────────────────┐
│                    ПОИСК ПО НОДАМ (/)                               │
└─────────────────────────────────────────────────────────────────────┘

1. Пользователь нажимает '/'
   │
2. ├─► KeybindingViewModel → 'app.openSearchMode'
   │    │
   │    ├─► ModeViewModel.setMode('search')
   │    └─► CommandLine открывается
   │
3. ├─► Пользователь вводит поисковый запрос
   │
4. ├─► SearchViewModel.search(query)
   │    │
   │    ├─► GraphRepository.getNodes()
   │    ├─► Фильтрация по label (case-insensitive)
   │    └─► Возвращает массив matching nodeIds
   │
5. ├─► ColoringService.setActiveNodes(matchingIds)
   │    │
   │    └─► activeNodeIds = Set(matchingIds)
   │
6. ├─► ColoringViewModel вычисляет стили:
   │    ├─► Matching ноды → обычные стили
   │    └─► Остальные ноды → inactive стиль (полупрозрачные)
   │
7. ├─► CameraService.fitAll(matchingIds)
   │
8. ├─► EventBus.emit('search:completed', { results: matchingIds })
   │
9. └─► Пользователь может навигировать по результатам (n/N)
```

---

## 8. Оптимизации производительности

### 8.1 Frontend оптимизации

#### 8.1.1 Дифференциальное обновление стилей

**Проблема:**
Текущая реализация useNodeColoring обновляет стили ВСЕХ нод при любом изменении состояния. Для графа с 1000 нодами это означает 1000 операций обновления.

**Решение:**
IColoringService реализует метод `computeChangedStyles(oldState, newState)`, который:

1. Определяет какие параметры изменились (selectedNodeId, focusedNodeId, и т.д.)
2. Вычисляет множество затронутых нод:
   - При смене selected: старый selected + новый selected + их incoming/outgoing
   - При смене focused: старый focused + новый focused
   - При смене activeNodes: симметричная разница старых и новых
3. Возвращает массив только измененных стилей

**Ожидаемый результат:**
При навигации обновляется 2 ноды вместо 1000. При выборе — ~10-50 нод вместо 1000.

#### 8.1.2 Batch-обновления vis-network

**Проблема:**
Множественные вызовы `dataSet.update()` триггерят перерисовку каждый раз.

**Решение:**
GraphRepository использует BatchedNotifier:

1. При вызове updateNodes() изменения накапливаются
2. Уведомление подписчиков откладывается через queueMicrotask()
3. Все изменения применяются одним batch-обновлением
4. Перерисовка происходит один раз

#### 8.1.3 Мемоизация вычисления стилей

**Проблема:**
Функции getNodeStyle() вызываются повторно с одинаковыми параметрами.

**Решение:**
ColoringService кэширует результаты computeNodeStyle() с инвалидацией при изменении состояния.

### 8.2 Backend оптимизации

#### 8.2.1 Lazy-компиляция регулярных выражений

**Проблема:**
Regex компилируются при каждом вызове parse_markdown().

**Решение:**
Использование lazy_static для однократной компиляции:
- WIKI_LINK_REGEX: `\[\[([^\]]+)\]\]`
- HASHTAG_REGEX: `#(\w+)`

**Ожидаемый результат:**
Ускорение парсинга в ~5-10 раз для больших коллекций.

#### 8.2.2 Инвертированный индекс входящих ссылок

**Проблема:**
count_incoming_links() имеет сложность O(n*m) — итерирует все файлы и их ссылки.

**Решение:**
GraphCache поддерживает два индекса:
- `links: HashMap<String, Vec<String>>` — исходящие ссылки (file → [targets])
- `incoming_links: HashMap<String, HashSet<String>>` — входящие ссылки (target → [sources])

При обновлении ссылок файла:
1. Удалить старые записи из incoming_links
2. Добавить новые записи в incoming_links
3. Обновить links

**Ожидаемый результат:**
count_incoming_links() становится O(1) вместо O(n*m).

#### 8.2.3 Однопроходное построение графа

**Проблема:**
build_graph() парсит каждый файл дважды.

**Решение:**
Кэширование результатов парсинга в HashMap<String, ParsedContent>:
1. Первый проход: парсинг + кэширование + создание ребер + подсчет ссылок
2. Второй проход: создание нод используя кэш (без повторного парсинга)

**Ожидаемый результат:**
Сокращение времени build_graph() в ~2 раза.

#### 8.2.4 Исправление race condition

**Проблема:**
При удалении ссылки count_incoming_links() вызывается до обновления кэша.

**Решение:**
1. Сначала обновить кэш (удалить ссылку из incoming_links)
2. Затем вызвать count_incoming_links()
3. Или: передавать offset (-1) при подсчете для удаляемой ссылки

---

## 9. Пофазный план реализации

### 9.1 Общая стратегия

**Подход:** Постепенная миграция с feature flags

Каждый новый компонент создается параллельно со старым. Feature flag позволяет переключаться между реализациями. Это обеспечивает:
- Возможность отката при проблемах
- Постепенную валидацию изменений
- Непрерывную работоспособность приложения

### 9.2 Фаза 0: Подготовка инфраструктуры

**Длительность:** 2-3 дня

**Цель:** Создать базовую инфраструктуру для новой архитектуры.

**Задачи:**

1. **Создание структуры директорий**
   - `src/core/interfaces/` — все интерфейсы
   - `src/core/services/` — реализации сервисов
   - `src/core/di/` — DI-контейнер
   - `src/core/mocks/` — mock-реализации для тестов
   - `src/core/config/` — feature flags и конфигурация

2. **Определение интерфейсов**
   - Создать файлы для каждого интерфейса (IGraphRepository.ts, и т.д.)
   - Определить все методы с типами параметров и возвращаемых значений
   - Добавить JSDoc-документацию

3. **Создание DI-контейнера**
   - ServiceContainer interface
   - ServiceContext (React Context)
   - ServiceProvider component
   - Хуки useService и convenience-хуки для каждого сервиса

4. **Настройка feature flags**
   - Создать файл featureFlags.ts
   - Определить флаги: USE_NEW_GRAPH_REPOSITORY, USE_NEW_CAMERA_SERVICE, и т.д.
   - Реализовать механизм чтения флагов (env или localStorage)

5. **Настройка тестирования**
   - Установить Vitest
   - Создать vitest.config.ts
   - Настроить пути и coverage

**Критерии завершения:**
- Все интерфейсы определены и задокументированы
- DI-контейнер работает (можно создать пустой контейнер)
- Feature flags система функционирует
- Vitest настроен и запускается

### 9.3 Фаза 1: Извлечение сервисов Model Layer

**Длительность:** 4-5 дней

**Цель:** Создать реализации сервисов Model Layer, не затрагивая существующий код.

**Задачи по сервисам:**

1. **IGraphRepository** (2 дня)
   - Создать GraphRepository class
   - Реализовать все методы интерфейса
   - Мигрировать логику из GraphDataService (только работа с данными)
   - Написать unit-тесты
   - Feature flag: USE_NEW_GRAPH_REPOSITORY

2. **ICameraService** (0.5 дня)
   - Создать CameraService class
   - Консолидировать логику из существующего CameraService
   - Сделать singleton через DI
   - Написать unit-тесты
   - Feature flag: USE_NEW_CAMERA_SERVICE

3. **IColoringService** (1.5 дня)
   - Создать ColoringService class
   - Извлечь логику стилей из coloringStore
   - Реализовать computeChangedStyles()
   - Написать unit-тесты
   - Feature flag: USE_NEW_COLORING_SERVICE

4. **IEventBus** (0.5 дня)
   - Создать EventBus class
   - Реализовать pub/sub механизм
   - Написать unit-тесты

5. **IKeybindingService** (0.5 дня)
   - Создать KeybindingService class
   - Мигрировать маппинг клавиш из keybindingStore
   - Написать unit-тесты

6. **IConfigRepository** (0.5 дня)
   - Создать TauriConfigRepository class
   - Обернуть Tauri command get_config
   - Написать unit-тесты

**Интеграция:**
- Обновить createProductionContainer() для создания всех сервисов
- Добавить ServiceProvider в App.tsx (пока не используется)
- Создать mock-реализации для тестов

**Критерии завершения:**
- Все сервисы реализованы и имеют unit-тесты
- Feature flags позволяют включить новые сервисы
- При включении флагов приложение работает как раньше

### 9.4 Фаза 2: Создание ViewModels

**Длительность:** 5-6 дней

**Цель:** Создать ViewModels, которые используют новые сервисы.

**Задачи по ViewModels:**

1. **GraphViewModel** (1.5 дня)
   - Zustand store для состояния загрузки графа
   - Использует IGraphRepository, IEventBus, IConfigRepository
   - Логика инициализации приложения
   - Обработка delta-событий от backend
   - Feature flag: USE_NEW_GRAPH_VM

2. **NavigationViewModel** (1.5 дня)
   - Zustand store для состояния навигации
   - Использует INavigationService, ICameraService, IColoringService
   - Методы: navigateLeft/Right/Up/Down, navigateNextConnected, navigatePrevConnected
   - Feature flag: USE_NEW_NAVIGATION_VM

3. **ColoringViewModel** (1.5 дня)
   - Zustand store для визуального состояния
   - Использует IColoringService, IGraphRepository
   - Подписка на изменения IColoringService
   - Применение стилей через IGraphRepository
   - Feature flag: USE_NEW_COLORING_VM

4. **KeybindingViewModel** (1 день)
   - Zustand store для обработки клавиш
   - Использует IKeybindingService
   - Command pattern: action → handler mapping
   - Вызывает методы других ViewModels
   - Feature flag: USE_NEW_KEYBINDING_VM

5. **SearchViewModel** (0.5 дня)
   - Zustand store для поиска
   - Использует IGraphRepository, IColoringService
   - Методы: search(), clearSearch(), navigateResults()
   - Feature flag: USE_NEW_SEARCH_VM

6. **CameraViewModel** (0.5 дня)
   - Zustand store для камеры
   - Использует ICameraService
   - Методы: zoomIn(), zoomOut(), resetView()
   - Feature flag: USE_NEW_CAMERA_VM

**Критерии завершения:**
- Все ViewModels реализованы с unit и integration тестами
- При включении feature flags функциональность сохраняется
- Нет прямых обращений к старым сервисам в новых ViewModels

### 9.5 Фаза 3: Упрощение Views

**Длительность:** 2-3 дня

**Цель:** Сделать View-компоненты "тупыми" — только отображение и передача событий.

**Задачи:**

1. **GraphCanvas**
   - Удалить прямые импорты сервисов
   - Использовать хуки useGraphViewModel, useColoringViewModel
   - Оставить только рендеринг vis-network контейнера

2. **CommandLine**
   - Использовать useSearchViewModel, useKeyindingViewModel
   - Только input и отображение режима

3. **PreviewPopup**
   - Создать PreviewViewModel
   - Компонент только отображает markdown

4. **GraphControls**
   - Использовать useCameraViewModel
   - Только кнопки и их onClick handlers

**Критерии завершения:**
- View-компоненты не содержат бизнес-логики
- Нет прямых импортов сервисов в View
- Все данные приходят через ViewModels

### 9.6 Фаза 4: Оптимизация производительности Frontend

**Длительность:** 3-4 дня

**Цель:** Реализовать оптимизации для работы с большими графами.

**Задачи:**

1. **Дифференциальное обновление стилей** (1.5 дня)
   - Реализовать computeChangedStyles() в ColoringService
   - Интегрировать в ColoringViewModel
   - Benchmark: сравнить время обновления до/после

2. **Batch-обновления** (1 день)
   - Реализовать BatchedNotifier в GraphRepository
   - Использовать queueMicrotask для отложенного уведомления
   - Benchmark: измерить количество перерисовок

3. **Мемоизация стилей** (0.5 дня)
   - Добавить кэш в computeNodeStyle()
   - Инвалидация при изменении состояния

4. **Тестирование производительности** (1 день)
   - Создать benchmark-тесты
   - Протестировать на графах 100, 500, 1000, 5000 нод
   - Задокументировать результаты

**Критерии завершения:**
- Навигация на графе 1000 нод < 16ms (60fps)
- Выбор ноды на графе 1000 нод < 50ms
- Benchmark-тесты включены в CI

### 9.7 Фаза 5: Backend оптимизации — Производительность

**Длительность:** 3-4 дня

**Цель:** Ускорить парсинг и построение графа.

**Задачи:**

1. **Lazy-компиляция regex** (0.5 дня)
   - Добавить lazy_static в Cargo.toml
   - Заменить Regex::new() на lazy_static!
   - Benchmark: время парсинга 1000 файлов

2. **Инвертированный индекс** (1.5 дня)
   - Добавить incoming_links в GraphCache
   - Обновить методы update_links(), remove_file()
   - Переписать count_incoming_links() на O(1)
   - Unit-тесты для корректности индекса

3. **Однопроходное построение графа** (1 день)
   - Добавить parsed_cache в build_graph()
   - Рефакторинг: один проход парсинга + создание нод
   - Benchmark: время build_graph() до/после

4. **Извлечение общего кода** (0.5 дня)
   - Создать helper: resolve_file_path(node_id, root_dir)
   - Использовать в open_file, create_phantom_node, read_note
   - Unit-тесты

**Критерии завершения:**
- Парсинг 1000 файлов < 500ms
- build_graph() для 1000 файлов < 1s
- Все изменения покрыты тестами

### 9.8 Фаза 6: Backend оптимизации — Надежность

**Длительность:** 3-4 дня

**Цель:** Исправить баги и улучшить обработку ошибок.

**Задачи:**

1. **Исправление race condition** (1 день)
   - Исправить порядок операций в handle_file_modified()
   - Сначала обновлять кэш, потом считать ссылки
   - Unit-тесты для edge cases

2. **Валидация конфигурации** (1 день)
   - Добавить метод validate() в AppConfig
   - Проверка существования root_dir
   - Проверка доступности template_phantom_node
   - Информативные сообщения об ошибках

3. **Типизированные ошибки** (1 день)
   - Добавить thiserror в Cargo.toml
   - Создать enum GraphError с вариантами
   - Заменить Result<T, String> на Result<T, GraphError>
   - Реализовать Into<String> для совместимости с Tauri

4. **Исправление panic на mutex** (0.5 дня)
   - Заменить .unwrap() на proper error handling
   - Использовать .map_err() для mutex poisoning

**Критерии завершения:**
- Нет panic-ов при нормальной работе
- Валидация конфигурации при запуске
- Типизированные ошибки во всех модулях

### 9.9 Фаза 7: ts-rs интеграция

**Длительность:** 2-3 дня

**Цель:** Автоматическая генерация TypeScript типов из Rust.

**Задачи:**

1. **Настройка ts-rs** (0.5 дня)
   - Добавить ts-rs в Cargo.toml
   - Настроить output directory (bindings/)

2. **Аннотация типов** (1 день)
   - Добавить #[derive(TS)] к Node, Edge, GraphData
   - Добавить к AppConfig, GraphDeltaEvent
   - Настроить экспорт

3. **Интеграция в build** (0.5 дня)
   - Создать скрипт генерации (npm run generate-types)
   - Интегрировать в CI pipeline

4. **Миграция frontend типов** (1 день)
   - Заменить ручные типы на сгенерированные
   - Удалить дублирующие определения
   - Проверить совместимость

**Критерии завершения:**
- Типы генерируются автоматически
- Frontend использует сгенерированные типы
- CI проверяет синхронизацию типов

### 9.10 Фаза 8: Финализация

**Длительность:** 2-3 дня

**Цель:** Удалить legacy код и провести полное тестирование.

**Задачи:**

1. **Включение новой архитектуры по умолчанию** (0.5 дня)
   - Установить все feature flags в true
   - Smoke-тестирование

2. **Удаление legacy кода** (1 день)
   - Удалить старый GraphDataService
   - Удалить старые stores (coloringStore, и др.)
   - Удалить старые hooks
   - Удалить feature flags

3. **Полная регрессия** (1 день)
   - Тестирование всех пользовательских сценариев
   - E2E тесты критических путей
   - Тестирование на реальных данных

4. **Исправление найденных проблем** (0.5 дня)
   - Bug fixes
   - Performance tuning

**Критерии завершения:**
- Legacy код удален
- Все тесты проходят
- Приложение работает стабильно

### 9.11 Фаза 9: Документация

**Длительность:** 1-2 дня

**Цель:** Обновить документацию проекта.

**Задачи:**

1. **Обновление CLAUDE.md**
   - Новая структура директорий
   - Описание архитектуры MVVM
   - Обновленные команды

2. **JSDoc для TypeScript**
   - Документация всех публичных интерфейсов
   - Примеры использования
   - @remarks для важных деталей

3. **Rust doc comments**
   - Документация публичных функций
   - Примеры
   - Описание ошибок

4. **README с диаграммами**
   - Архитектурная диаграмма
   - Диаграмма потоков данных
   - Инструкции по разработке

**Критерии завершения:**
- Вся документация актуальна
- Новый разработчик может понять архитектуру из документации

---

## 10. Структура файлов проекта

### 10.1 Текущая структура (до миграции)

```
src/
├── app/
│   ├── App.tsx
│   └── main.tsx
├── features/
│   ├── graph/
│   │   ├── components/
│   │   │   └── GraphCanvas.tsx
│   │   ├── hooks/
│   │   │   ├── useGraphNetwork.ts
│   │   │   ├── useGraphDeltaSync.ts
│   │   │   └── ...
│   │   └── services/
│   │       └── GraphDataService.ts  ← God Object
│   ├── coloring/
│   │   ├── hooks/
│   │   │   └── useNodeColoring.ts
│   │   └── store/
│   │       └── coloringStore.ts  ← Mixed concerns
│   ├── navigation/
│   │   └── hooks/
│   │       ├── useVimNavigation.ts
│   │       └── useConnectedNavigation.ts
│   ├── keybindings/
│   │   ├── hooks/
│   │   │   └── useKeybindings.ts  ← Monolith
│   │   └── store/
│   │       └── keybindingStore.ts
│   ├── camera/
│   │   ├── services/
│   │   │   └── CameraService.ts
│   │   └── store/
│   │       └── cameraStore.ts
│   ├── command-line/
│   └── preview/
├── infrastructure/
│   ├── tauri/
│   │   ├── commands.ts
│   │   └── events.ts
│   └── services/
│       └── GraphSyncService.ts
└── shared/
    ├── types/
    │   └── domain.ts
    └── store/
        └── appModeStore.ts
```

### 10.2 Целевая структура (после миграции)

```
src/
├── app/
│   ├── App.tsx                    ← ServiceProvider wrapper
│   └── main.tsx
│
├── core/                          ← NEW: Core architecture
│   ├── interfaces/                ← Service interfaces
│   │   ├── IGraphRepository.ts
│   │   ├── INavigationService.ts
│   │   ├── ICameraService.ts
│   │   ├── IColoringService.ts
│   │   ├── IEventBus.ts
│   │   ├── IKeybindingService.ts
│   │   ├── IConfigRepository.ts
│   │   └── index.ts
│   │
│   ├── services/                  ← Service implementations
│   │   ├── GraphRepository.ts
│   │   ├── NavigationService.ts
│   │   ├── CameraService.ts
│   │   ├── ColoringService.ts
│   │   ├── EventBus.ts
│   │   ├── KeybindingService.ts
│   │   ├── TauriConfigRepository.ts
│   │   └── index.ts
│   │
│   ├── di/                        ← Dependency Injection
│   │   ├── container.ts           ← ServiceContainer, ServiceProvider
│   │   ├── createContainer.ts     ← Factory functions
│   │   ├── hooks.ts               ← useService, useGraphRepository, etc.
│   │   └── index.ts
│   │
│   ├── mocks/                     ← Mock implementations for tests
│   │   ├── MockGraphRepository.ts
│   │   ├── MockNavigationService.ts
│   │   └── ...
│   │
│   └── config/
│       └── featureFlags.ts        ← Feature flags (temporary)
│
├── viewmodels/                    ← NEW: ViewModels
│   ├── GraphViewModel.ts
│   ├── NavigationViewModel.ts
│   ├── ColoringViewModel.ts
│   ├── KeybindingViewModel.ts
│   ├── SearchViewModel.ts
│   ├── CameraViewModel.ts
│   ├── PreviewViewModel.ts
│   ├── ModeViewModel.ts
│   └── index.ts
│
├── views/                         ← Simplified Views
│   ├── GraphCanvas/
│   │   ├── GraphCanvas.tsx
│   │   └── index.ts
│   ├── CommandLine/
│   │   ├── CommandLine.tsx
│   │   └── index.ts
│   ├── PreviewPopup/
│   │   ├── PreviewPopup.tsx
│   │   └── index.ts
│   └── GraphControls/
│       ├── GraphControls.tsx
│       └── index.ts
│
├── infrastructure/                ← External dependencies
│   ├── tauri/
│   │   ├── TauriAdapter.ts
│   │   └── index.ts
│   ├── vis-network/
│   │   ├── VisNetworkAdapter.ts
│   │   ├── DataSetManager.ts
│   │   └── index.ts
│   └── index.ts
│
├── shared/
│   ├── types/
│   │   ├── domain.ts              ← Node, Edge, GraphData
│   │   ├── events.ts              ← Event types
│   │   └── index.ts
│   └── utils/
│       └── index.ts
│
└── __tests__/                     ← NEW: Tests
    ├── unit/
    │   ├── services/
    │   └── viewmodels/
    ├── integration/
    └── e2e/
```

### 10.3 Backend структура (без изменений в организации)

```
src-tauri/src/
├── main.rs
├── lib.rs                         ← Tauri setup + commands registration
├── scanner/
│   └── mod.rs                     ← Directory scanning
├── parser/
│   └── mod.rs                     ← Markdown parsing (+ lazy_static)
├── graph/
│   └── mod.rs                     ← Graph building (+ caching)
├── config/
│   └── mod.rs                     ← Configuration (+ validation)
├── commands/
│   └── mod.rs                     ← Tauri commands (+ helpers)
├── helpers/
│   └── mod.rs                     ← Template variables
├── templates/
│   └── mod.rs                     ← File creation
├── watcher/
│   ├── mod.rs                     ← File watcher setup
│   ├── cache.rs                   ← Graph cache (+ inverted index)
│   ├── delta.rs                   ← Delta calculation (+ race fix)
│   └── events.rs                  ← Event emitting
└── errors/                        ← NEW: Typed errors
    └── mod.rs
```

---

## 11. Риски и митигация

### 11.1 Технические риски

| Риск | Вероятность | Влияние | Митигация |
|------|-------------|---------|-----------|
| Поломка vis-network интеграции | Средняя | Высокое | Adapter layer изолирует vis-network; unit-тесты; feature flags для отката |
| Рассинхронизация состояния | Средняя | Высокое | Single source of truth; EventBus для координации; интеграционные тесты |
| Регрессия производительности | Низкая | Среднее | Benchmark-тесты; профилирование; сравнение до/после |
| Регрессия функциональности | Низкая | Высокое | E2E тесты; ручное тестирование; feature flags |

### 11.2 Процессные риски

| Риск | Вероятность | Влияние | Митигация |
|------|-------------|---------|-----------|
| Недооценка сложности | Средняя | Среднее | Поэтапная реализация; buffer time в оценках |
| Блокировки между фазами | Низкая | Среднее | Независимые фазы где возможно; параллельная работа backend/frontend |
| Потеря контекста при долгой реализации | Средняя | Низкое | Подробная документация; commit messages; code reviews |

### 11.3 Стратегия отката

Для каждой фазы определена стратегия отката:

1. **Feature flags** — мгновенное переключение на старый код
2. **Git tags** — точки стабильного состояния перед каждой фазой
3. **Параллельный код** — старый код не удаляется до Фазы 8
4. **Интеграционные тесты** — проверка поведения при переключении

---

## 12. Критерии приемки

### 12.1 Функциональные критерии

- [ ] Все существующие функции работают после миграции
- [ ] Навигация hjkl работает корректно
- [ ] Навигация w/b работает корректно
- [ ] Выбор ноды (Space) подсвечивает связи
- [ ] Поиск (/) фильтрует ноды
- [ ] Открытие файла (o) запускает nvim
- [ ] Превью (p) показывает содержимое
- [ ] Escape возвращает к нормальному режиму
- [ ] File watcher синхронизирует изменения

### 12.2 Производительные критерии

- [ ] Навигация на графе 1000 нод < 16ms (60fps)
- [ ] Выбор ноды на графе 1000 нод < 50ms
- [ ] Парсинг 1000 файлов < 500ms
- [ ] Построение графа 1000 файлов < 1s
- [ ] Потребление памяти не увеличилось более чем на 20%

### 12.3 Архитектурные критерии

- [ ] Все сервисы реализуют интерфейсы
- [ ] Нет прямых импортов сервисов в View-компонентах
- [ ] ViewModels используют DI для получения сервисов
- [ ] Все сервисы имеют unit-тесты
- [ ] ViewModels имеют integration-тесты
- [ ] Критические пути покрыты E2E тестами
- [ ] Документация актуальна

### 12.4 Качественные критерии

- [ ] Нет TypeScript ошибок (strict mode)
- [ ] Нет ESLint warnings
- [ ] Нет Rust warnings (clippy)
- [ ] Code coverage > 70%
- [ ] Нет TODO/FIXME без issue reference

---

## Приложения

### A. Глоссарий

| Термин | Определение |
|--------|------------|
| **Node** | Узел графа, представляющий markdown-файл |
| **Edge** | Ребро графа, представляющее wiki-ссылку между файлами |
| **Phantom Node** | Узел для несуществующего файла, на который есть ссылки |
| **Wiki-link** | Ссылка формата `[[имя]]` в markdown-файле |
| **Focus** | Визуальный индикатор текущей позиции навигации |
| **Selection** | Выбранная нода с подсветкой связей |
| **Delta** | Инкрементальное изменение графа |

### B. Ссылки

- [vis-network документация](https://visjs.github.io/vis-network/docs/network/)
- [Zustand документация](https://docs.pmnd.rs/zustand/getting-started/introduction)
- [Tauri 2.0 документация](https://v2.tauri.app/)
- [SOLID принципы](https://en.wikipedia.org/wiki/SOLID)
- [MVVM паттерн](https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93viewmodel)

---

*Документ создан: 2025-11-28*
*Последнее обновление: 2025-11-28*
